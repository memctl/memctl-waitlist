---
---

<div class="rounded-xl border border-[var(--border)] bg-[var(--surface)] overflow-hidden shadow-[var(--card-shadow)]">
  <!-- Title bar -->
  <div class="flex items-center gap-2 px-4 py-2 border-b border-[var(--border)] bg-[var(--code-bg)]">
    <div class="flex items-center gap-1.5">
      <div class="w-3 h-3 rounded-full bg-[#FF5F57]"></div>
      <div class="w-3 h-3 rounded-full bg-[#FEBC2E]"></div>
      <div class="w-3 h-3 rounded-full bg-[#28C840]"></div>
    </div>
    <span class="text-xs text-[var(--tertiary)] font-mono ml-2">terminal</span>
  </div>
  <!-- Terminal body -->
  <div data-terminal class="p-5 font-mono text-[13px] leading-[1.8] min-h-[280px]"></div>
</div>

<script>
  function initTerminal() {
    const el = document.querySelector('[data-terminal]') as HTMLElement;
    if (!el) return;

    const sequences = [
      {
        cmd: 'memctl init',
        output: [
          { text: 'Initialized memory store for ', suffix: '<span class="text-[#F97316]">my-project</span>' },
        ],
      },
      {
        cmd: 'memctl status',
        output: [
          { text: 'Branch: ', suffix: '<span class="text-[#F97316]">feature/auth</span>' },
          { text: 'Memories: ', suffix: '<span style="color:var(--text)">23 entries</span> · 3 agents connected' },
          { text: 'Protocol: ', suffix: '<span style="color:var(--text)">MCP v1</span> · Synced <span class="text-[#F97316]">✓</span>' },
        ],
      },
      {
        cmd: 'memctl recall "auth flow"',
        output: [
          { text: 'Found ', suffix: '<span style="color:var(--text)">4 memories</span> across 2 branches' },
          { text: 'Latest: ', suffix: '<span style="color:var(--text)">OAuth2 PKCE flow with refresh tokens</span>' },
          { text: 'Source: ', suffix: '<span style="color:var(--tertiary)">cursor</span> · 2h ago · by <span style="color:var(--text)">sarah</span>' },
        ],
      },
      {
        cmd: 'memctl share --team',
        output: [
          { text: '<span class="text-[#F97316]">✓</span> Shared ', suffix: '<span style="color:var(--text)">4 memories</span> with team <span class="text-[#F97316]">acme-corp</span>' },
          { text: 'Members notified: ', suffix: '<span style="color:var(--text)">jake, priya, sarah</span>' },
        ],
      },
    ];

    let seqIdx = 0;
    let lines: string[] = [];
    let aborted = false;

    function sleep(ms: number) {
      return new Promise(r => setTimeout(r, ms));
    }

    function render() {
      el.innerHTML = lines.join('');
    }

    function addLine(html: string) {
      lines.push(`<div>${html}</div>`);
      render();
    }

    async function typeCmd(cmd: string) {
      const prompt = '<span style="color:var(--tertiary)">$</span> ';
      let typed = '';
      lines.push(`<div>${prompt}<span style="color:var(--text)">${typed}</span><span class="animate-blink" style="color:var(--tertiary)">▋</span></div>`);
      render();

      for (const ch of cmd) {
        if (aborted) return;
        typed += ch;
        lines[lines.length - 1] = `<div>${prompt}<span style="color:var(--text)">${typed}</span><span class="animate-blink" style="color:var(--tertiary)">▋</span></div>`;
        render();
        await sleep(40 + Math.random() * 30);
      }
      // Remove cursor
      lines[lines.length - 1] = `<div>${prompt}<span style="color:var(--text)">${typed}</span></div>`;
      render();
    }

    async function showOutput(output: { text: string; suffix: string }[]) {
      for (const line of output) {
        if (aborted) return;
        await sleep(100);
        addLine(`<span style="color:var(--secondary)">${line.text}${line.suffix}</span>`);
      }
    }

    async function runLoop() {
      while (!aborted) {
        const seq = sequences[seqIdx % sequences.length];
        if (lines.length > 0) {
          // Add spacing between commands
          lines.push('<div class="h-2"></div>');
          render();
          await sleep(200);
        }
        await typeCmd(seq.cmd);
        await sleep(300);
        await showOutput(seq.output);
        seqIdx++;

        // After all 4 sequences, pause and reset
        if (seqIdx % sequences.length === 0) {
          await sleep(3000);
          lines = [];
          render();
          await sleep(600);
        } else {
          await sleep(800);
        }
      }
    }

    // Start when visible
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          observer.disconnect();
          runLoop();
        }
      },
      { threshold: 0.3 }
    );
    observer.observe(el);

    // Cleanup on page navigation
    document.addEventListener('astro:before-swap', () => { aborted = true; }, { once: true });
  }

  initTerminal();
  document.addEventListener('astro:after-swap', initTerminal);
</script>
